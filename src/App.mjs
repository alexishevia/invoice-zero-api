import { v1 as uuidv1 } from 'uuid';
import InMemoryPersistence from './persistence/Memory.mjs';
import FilePersistence from './persistence/File.mjs';
import validate from './validate.mjs';
import { NotFoundError } from './errors.mjs';
import * as Account from './Account.mjs';

function getPersistenceFromOptions({ type, filepath } = {}) {
  switch(type) {
    case 'file':
      return new FilePersistence({ filepath });
    default:
      return new InMemoryPersistence();
  }
}

function getTimestamp() {
  return new Date().toISOString();
}

const Category = {
  required: {
    name: (val) => validate(val).string().notEmpty(),
  },
  autoGenerated: new Set(['id', 'deleted', 'modifiedAt'])
};

export default function App(options = {}) {
  const persistence = getPersistenceFromOptions(options.persistence);
  const state = {
    accounts: {},
    categories: {},
    income: {},
  };

  function processEvent(event) {
    let processed = false;
    for (const type of Object.keys(Account.actions)) {
      if (event.type === type) {
        processed = true;
        return Account.actions[type].process({
          state,
          id: event.id,
          payload: event.payload,
          timestamp: event.timestamp,
        });
      }
    }
    if (!processed) {
      throw new Error(`unknown event.type: ${event.type}`);
    }
  }

  function dispatch(event) {
    const augmented = {
      id: uuidv1(),
      timestamp: getTimestamp(),
      type: event.type,
      payload: event.payload,
    };
    persistence.append(augmented)
    processEvent(augmented);
  }

  return {
    start: async () => {
      // hydrate state
      await persistence.forEach(processEvent);
    },

    // accounts
    createAccount: (data) => {
      const type = 'accounts/create';
      const payload = Account.actions[type].payload(data);
      dispatch({ type, payload });
      return state.accounts[payload.id];
    },
    updateAccount: (id, data) => {
      const type = 'accounts/update';
      const payload = Account.actions[type].payload(state, id, data);
      if (payload) { dispatch({ type, payload }); }
      return state.accounts[id];
    },
    deleteAccount: (id) => {
      const type = 'accounts/delete';
      const payload = Account.actions[type].payload(state, id);
      if (payload) { dispatch({ type, payload }); }
      return;
    },
    getAccountByID: (id) => {
      if (state.accounts[id]) { return state.accounts[id]; }
      throw new NotFoundError(`no account with id: ${id}`);
    },
    listAccounts: () => Object.values(state.accounts),

    // categories
    // createCategory: (data) => actions.create('categories/create', {
    //   dispatch, data, model: Category,
    // }),
    // updateCategory: (id, data) => actions.update('categories/update', {
    //   dispatch, data, model: Category, original: state.categories[id]
    // }),
    // deleteCategory: (id) => actions.destroy('categories/delete', {
    //   dispatch, model: Category, original: state.categories[id]
    // }),
    // getCategoryByID: (id) => {
    //   if (state.categories[id]) {
    //     return state.categories[id];
    //   }
    //   throw new NotFoundError(`no category with id: ${id}`);
    // },
    // listCategories: () => Object.values(state.categories),

    // income
    // listIncome: () => Object.values(state.income),
  };

}
