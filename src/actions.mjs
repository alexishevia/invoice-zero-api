import { v1 as uuidv1 } from 'uuid';
import { InvalidRequestError, NotFoundError, ConflictError } from './errors.mjs';

function usesAutoGeneratedField(model, field) {
  return model.autoGenerated
    && model.autoGenerated.hasOwnProperty(field)
    && model.autoGenerated[field];
}

// "create" actions add objects to the app state
export function create(type, { dispatch, data, model }) {
  const payload = {}

  const required = model.required || {};
  const optional = model.optional || {};

  // required fields
  Object.keys(required).forEach((key) => {
    if (!data.hasOwnProperty(key)) {
      throw new InvalidRequestError(`missing required field: ${key}`);
    }
  });

  // copy fields from request into action payload
  Object.entries(data).forEach(([key, val]) => {
    const validateFunc = required[key] || optional[key];
    if (!validateFunc) {
      throw new InvalidRequestError(`field is not supported: ${key}`);
    }
    try {
      validateFunc(val);
    } catch(err) {
      throw new InvalidRequestError(`${key}: ${err.message}`);
    }
    payload[key] = val;
  });

  // auto-generated fields
  if (usesAutoGeneratedField(model, 'id')) {
    payload.id = uuidv1();
  }
  if (usesAutoGeneratedField(model, 'deleted')) {
    payload.deleted = false;
  }
  if (usesAutoGeneratedField(model, 'modifiedAt')) {
    payload.modifiedAt = new Date().toISOString();
  }

  dispatch({ type, payload });
  return payload;
}

// "update" actions modify data for an existing object
export function update(type, { dispatch, original, data, model }) {
  const required = model.required || {};
  const optional = model.optional || {};

  if (!original) {
    throw new NotFoundError(`${type} error: object not found`);
  }
  if (original.deleted) {
    throw new ConflictError(`${type} error: object has been deleted`);
  }

  const payload = { ...original };

  if (usesAutoGeneratedField(model, 'modifiedAt')) {
    payload.modifiedAt = new Date().toISOString();
  }

  let modified = false;

  // copy fields from request into action payload
  Object.entries(data).forEach(([key, val]) => {
    const validateFunc = required[key] || optional[key];
    if (!validateFunc) {
      throw new InvalidRequestError(`field is not supported: ${key}`);
    }
    try {
      validateFunc(val);
    } catch(err) {
      throw new InvalidRequestError(`${key}: ${err.message}`);
    }
    if (val !== payload[key]) {
      modified = true;
      payload[key] = val;
    }
  });

  if (!modified) {
    return original;
  }

  dispatch({ type, payload });
  return payload;
}

// "destroy" actions flag objects as deleted
export function destroy(type, { dispatch, original, model }) {
  if (!original) {
    throw new NotFoundError(`${type} error: object not found`);
  }
  if (!usesAutoGeneratedField(model, 'deleted')) {
    throw new Error(`newDeleteAction has no effect on ${type}`);
  }
  if (original.deleted) {
    return original;
  }
  const payload = { ...original, deleted: true };
  if (usesAutoGeneratedField(model, 'modifiedAt')) {
    payload.modifiedAt = new Date().toISOString();
  }
  dispatch({ type, payload });
  return payload;
}
